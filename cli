#!/usr/bin/env node -r esm

import path from 'path';
import { program } from 'commander';
import { promptFill } from './src/util/prompt';
import { restoreSnapshot } from './src/util/snapshot';
import { version } from './package.json';
import descriptor from './command.json';

program.version(version);
addCommand(program, descriptor);

function addCommand(command, descriptor) {
  const { description, arguments: args, options } = descriptor;
  command.description(description);
  if (args && args.length) {
    command.arguments(args.map((arg) => {
      const { name, required, prompt } = arg;
      return required && !prompt ? `<${name}>` : `[${name}]`;
    }).join(' '));
  }
  for (let option of options || []) {
    const { name, type, short, description, default: def } = option;
    const opts = [];
    if (short) {
      opts.push(`-${short}`);
    }
    if (name) {
      let l = `--${name}`;
      if (type && type !== 'boolean') {
        l += ` <${type}>`;
      }
      opts.push(l);
    }
    command.option(opts.join(', '), description, def);
  }
  for (let sub of descriptor.commands || []) {
    const { name } = sub;
    const subcommand = command.command(name);
    subcommand.storeOptionsAsProperties(false);
    const handler = require(path.resolve(__dirname, 'src', name)).default;
    addCommand(subcommand, sub);
    subcommand.action(async () => {
      const { snapshot, ...options } = subcommand.opts();
      if (snapshot) {
        Object.assign(options, await restoreSnapshot(snapshot));
      } else {
        const args = sub.arguments || [];
        if (args.length === 1 && args[0].type === 'multiple') {
          options[args[0].name] = subcommand.args;
        } else {
          subcommand.args.forEach((arg, i) => {
            const { name } = sub.arguments[i];
            options[name] = arg;
          });
        }
      }
      await promptFill(options, sub.arguments);
      await promptFill(options, sub.options);
      await handler(options);
    });
  }
}

program.parse(process.argv);
